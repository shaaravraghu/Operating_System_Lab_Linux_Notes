#include <iostream>
#include <dirent.h>
using namespace std;

int main(){
  DIR *dir;
  struct dir *entry;

  dir = opendir(".");

  while((entry = readdir(dir)) != NULL){
    string name = entry->d_name;
    if (entry != "." && entry != "..")
      cout << name << endl;
  }  

}







#include <iostream>
#include <unistd.h>
using namespace std;

int main(char *argv[]){
  if (unlink(argv[1]) == 0)
    cout << "Removed";
  else
    cout << "Error";
}















#include <fcntl.h>
#include <iostream>
#include <unistd.h>

int main(char *argv[]){
  int fd;
  char ch;

  fd = open(argv[1], O_RDONLY)

  if (fd == -1)
    cout << "Error";
  else{
    while (read(fd, &ch, 1) > 0){
      write(1, &ch, 1); 
    }
  }
}







#include <iostream>
#include <cctype>
#include <dirent.h>
using namespace std;

int main(){
  DIR *dir;
  struct dir *entry;

  dir = opendir("/proc");

  while((entry = readdir(dir)) != NULL){
    string name = entry->d_name;

    bool isNumber = true;
    for (char c : name){
      if (!isdigit(c)){
        isNumber = false;
        break;
      }
    }

    if (isNumber){
      cout<<name;
    }
  }  

}






















#include <cstdlib>
#include <iostream>
#include <signal.h>
using namespace std;

int main(char *argv[]){
  pid = atoi(argv[1]);
  if (kill(pid, SIGKILL) == 0){
    cout<< "Process Terminated";
  }
}














#include <iostream>
#include <fcntl.h>
#include <unistd.h>
using namespace std;

int main(int argc, char *argv[])
{

    int fd;
    char ch;
    int lines = 0, words = 0, characters = 0;
    bool inWord = false;

    fd = open(argv[1], O_RDONLY);

    if (fd == -1)
    {
        cout << "Error: File not found" << endl;
        return 1;
    }

    while (read(fd, &ch, 1) > 0)
    {
        characters++;

        if (ch == '\n')
            lines++;

        if (ch == ' ' || ch == '\n' || ch == '\t')
        {
            inWord = false;
        }
        else if (!inWord)
        {
            words++;
            inWord = true;
        }
    }

    close(fd);

    cout << "Lines: "      << lines      << endl;
    cout << "Words: "      << words      << endl;
    cout << "Characters: " << characters << endl;

    return 0;
}




























#include <iostream>
using namespace std;

int main()
{
    int n;
    cout << "Enter number of processes: ";
    cin >> n;

    int pid[n], bt[n], at[n];
    int rem[n], ct[n];
    bool done[n];

    for (int i = 0; i < n; i++)
    {
        cout << "Enter PID, Burst Time, Arrival Time: ";
        cin >> pid[i] >> bt[i] >> at[i];
        rem[i] = bt[i];
        done[i] = false;
    }

    int t = 0, completed = 0;
    int gantt[1000];  // stores which PID runs at each time unit

    while (completed < n)
    {
        // Find process with shortest remaining time that has arrived
        int idx = -1;
        int shortest = 99999;

        for (int i = 0; i < n; i++)
        {
            if (!done[i] && at[i] <= t && rem[i] < shortest)
            {
                shortest = rem[i];
                idx = i;
            }
        }

        if (idx == -1)  // no process has arrived yet, CPU idle
        {
            gantt[t] = -1;
            t++;
            continue;
        }

        // Run selected process for 1 unit
        gantt[t] = pid[idx];
        rem[idx]--;
        t++;

        // If process finished
        if (rem[idx] == 0)
        {
            ct[idx] = t;
            done[idx] = true;
            completed++;
        }
    }

    // Calculate TAT and WT
    int tat[n], wt[n];
    float avgTAT = 0, avgWT = 0;

    for (int i = 0; i < n; i++)
    {
        tat[i] = ct[i] - at[i];
        wt[i]  = tat[i] - bt[i];
        avgTAT += tat[i];
        avgWT  += wt[i];
    }

    avgTAT /= n;
    avgWT  /= n;

    // Print Gantt Chart
    cout << "\nGantt Chart:\n";
    int i = 0;
    while (i < t)
    {
        int j = i;
        while (j < t && gantt[j] == gantt[i]) j++;  // find how long same PID ran
        if (gantt[i] == -1)
            cout << "| IDLE ";
        else
            cout << "| P" << gantt[i] << " ";
        i = j;
    }
    cout << "|\n";

    // Print timeline
    i = 0;
    cout << "0";
    while (i < t)
    {
        int j = i;
        while (j < t && gantt[j] == gantt[i]) j++;
        cout << "\t" << j;
        i = j;
    }
    cout << "\n";

    // Print Table
    cout << "\nPID\tAT\tBT\tCT\tTAT\tWT\n";
    for (int i = 0; i < n; i++)
    {
        cout << pid[i] << "\t" << at[i] << "\t" << bt[i] << "\t"
             << ct[i] << "\t" << tat[i] << "\t" << wt[i] << "\n";
    }

    cout << "\nAverage TAT: " << avgTAT;
    cout << "\nAverage WT:  " << avgWT << "\n";

    return 0;
}



































#include <iostream>
#include <queue>
using namespace std;

int main()
{
    int n, quantum;
    cout << "Enter number of processes: ";
    cin >> n;
    cout << "Enter time quantum: ";
    cin >> quantum;

    int pid[n], bt[n], at[n];
    int rem[n], ct[n];
    bool inQueue[n];

    for (int i = 0; i < n; i++)
    {
        cout << "Enter PID, Burst Time, Arrival Time: ";
        cin >> pid[i] >> bt[i] >> at[i];
        rem[i] = bt[i];
        inQueue[i] = false;
    }

    // Sort by arrival time
    for (int i = 0; i < n - 1; i++)
        for (int j = 0; j < n - i - 1; j++)
            if (at[j] > at[j + 1])
            {
                swap(at[j], at[j+1]);
                swap(bt[j], bt[j+1]);
                swap(pid[j], pid[j+1]);
                swap(rem[j], rem[j+1]);
            }

    queue<int> q;  // stores index of process
    int t = 0, completed = 0;

    // Gantt chart storage
    int ganttPID[1000], ganttStart[1000], ganttEnd[1000];
    int g = 0;

    // Add first process
    q.push(0);
    inQueue[0] = true;

    while (completed < n)
    {
        if (q.empty())  // CPU idle, jump to next arrival
        {
            for (int i = 0; i < n; i++)
            {
                if (!inQueue[i] && rem[i] > 0)
                {
                    t = at[i];
                    q.push(i);
                    inQueue[i] = true;
                    break;
                }
            }
        }

        int idx = q.front();
        q.pop();

        // Run for min(quantum, remaining)
        int runTime = min(quantum, rem[idx]);

        ganttPID[g]   = pid[idx];
        ganttStart[g] = t;
        t += runTime;
        ganttEnd[g]   = t;
        g++;

        rem[idx] -= runTime;

        // Add newly arrived processes to queue
        for (int i = 0; i < n; i++)
            if (!inQueue[i] && at[i] <= t && rem[i] > 0)
            {
                q.push(i);
                inQueue[i] = true;
            }

        // If not done, push back
        if (rem[idx] > 0)
            q.push(idx);
        else
        {
            ct[idx] = t;
            completed++;
        }
    }

    // Calculate TAT and WT
    int tat[n], wt[n];
    float avgTAT = 0, avgWT = 0;

    for (int i = 0; i < n; i++)
    {
        tat[i] = ct[i] - at[i];
        wt[i]  = tat[i] - bt[i];
        avgTAT += tat[i];
        avgWT  += wt[i];
    }

    avgTAT /= n;
    avgWT  /= n;

    // Print Gantt Chart
    cout << "\nGantt Chart:\n";
    for (int i = 0; i < g; i++)
        cout << "| P" << ganttPID[i] << " ";
    cout << "|\n";

    cout << ganttStart[0];
    for (int i = 0; i < g; i++)
        cout << "\t" << ganttEnd[i];
    cout << "\n";

    // Print Table
    cout << "\nPID\tAT\tBT\tCT\tTAT\tWT\n";
    for (int i = 0; i < n; i++)
        cout << pid[i] << "\t" << at[i] << "\t" << bt[i] << "\t"
             << ct[i] << "\t" << tat[i] << "\t" << wt[i] << "\n";

    cout << "\nAverage TAT: " << avgTAT;
    cout << "\nAverage WT:  " << avgWT << "\n";

    return 0;
}



















#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
using namespace std;

// Binary Semaphore (value = 0 or 1)
struct BinarySemaphore
{
    int S = 1;
    mutex mtx;

    void wait()
    {
        while (true)
        {
            mtx.lock();
            if (S > 0) { S--; mtx.unlock(); return; }
            mtx.unlock();
            this_thread::sleep_for(chrono::milliseconds(10));
        }
    }

    void signal()
    {
        mtx.lock();
        S = 1;
        mtx.unlock();
    }
};

BinarySemaphore sem;

void process(int id)
{
    sem.wait();                  // lock — entry

    cout << "Process " << id << " ENTERED critical section\n";
    this_thread::sleep_for(chrono::milliseconds(500));  // simulate work
    cout << "Process " << id << " LEAVING critical section\n";

    sem.signal();                // unlock — exit
}

int main()
{
    thread t1(process, 1);
    thread t2(process, 2);
    thread t3(process, 3);

    t1.join();
    t2.join();
    t3.join();

    return 0;
}



















#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
using namespace std;

// Counting Semaphore (value = 0 to N)
struct CountingSemaphore
{
    int S;
    mutex mtx;

    CountingSemaphore(int n) { S = n; }  // set how many allowed at once

    void wait()
    {
        while (true)
        {
            mtx.lock();
            if (S > 0) { S--; mtx.unlock(); return; }
            mtx.unlock();
            this_thread::sleep_for(chrono::milliseconds(10));
        }
    }

    void signal()
    {
        mtx.lock();
        S++;
        mtx.unlock();
    }
};

CountingSemaphore sem(3);  // allow 3 processes at once (e.g. 3 printers)

void process(int id)
{
    sem.wait();

    cout << "Process " << id << " USING resource\n";
    this_thread::sleep_for(chrono::milliseconds(500));
    cout << "Process " << id << " DONE with resource\n";

    sem.signal();
}

int main()
{
    thread t1(process, 1);
    thread t2(process, 2);
    thread t3(process, 3);
    thread t4(process, 4);
    thread t5(process, 5);

    t1.join(); t2.join(); t3.join();
    t4.join(); t5.join();

    return 0;
}
